# Development Guide

## Domain Events Must Use #[MessageName] Attribute

```php
use Freyr\MessageBroker\Outbox\MessageName;
use Freyr\MessageBroker\Outbox\EventBridge\OutboxMessage;
use Freyr\MessageBroker\Outbox\Routing\{MessengerTransport, AmqpRoutingKey};
use Freyr\Identity\Id;

#[MessageName('order.placed')]  // REQUIRED
#[MessengerTransport('commerce')]     // OPTIONAL: Override default exchange
#[AmqpRoutingKey('order.test')] // OPTIONAL: Override routing key
final readonly class OrderPlaced implements OutboxMessage
{
    public function __construct(
        public Id $orderId,
        public float $totalAmount,
        public CarbonImmutable $placedAt,
    ) {}
}
```

**Critical Requirements:**
1. Every outbox event MUST have `#[MessageName('domain.subdomain.action')]` attribute
2. Every outbox event MUST implement `OutboxMessage` marker interface
3. NO `messageId` property - it's auto-generated by OutboxToAmqpBridge as UUID v7

See `docs/amqp-routing.md` for complete routing documentation.

## Inbox Message Handling (Typed Objects)

### 1. Define Message Class

```php
namespace App\Message;

use Freyr\Identity\Id;
use Carbon\CarbonImmutable;

final readonly class OrderPlaced
{
    public function __construct(
        public Id $orderId,
        public Id $customerId,
        public float $totalAmount,
        public CarbonImmutable $placedAt,
    ) {}
}
```

### 2. Configure Message Type Mapping

```yaml
# config/packages/message_broker.yaml
message_broker:
    inbox:
        message_types:
            'order.placed': 'App\Message\OrderPlaced'
            'user.registered': 'App\Message\UserRegistered'
```

### 3. Use Standard Messenger Handlers

```php
use Symfony\Component\Messenger\Attribute\AsMessageHandler;

#[AsMessageHandler]
final readonly class OrderPlacedHandler
{
    public function __invoke(OrderPlaced $message): void
    {
        // Type-safe access with IDE autocomplete!
        $orderId = $message->orderId;
        $amount = $message->totalAmount;
        // Process...
    }
}
```

**Benefits:**
- Type safety and IDE support
- Native Symfony serialization
- Supports value objects via custom normalizers
- Semantic message names (language-agnostic)
- Failed message retry safety

## Custom Serialization with Normalizers/Denormalizers

### Package-Provided Normalizers

- `IdNormalizer` - For `Freyr\Identity\Id` (UUID v7)
- `CarbonImmutableNormalizer` - For `Carbon\CarbonImmutable`

### Adding Custom Normalizers

**1. Create a Normalizer:**

```php
namespace App\Serializer\Normalizer;

use App\ValueObject\Money;
use Symfony\Component\Serializer\Normalizer\{DenormalizerInterface, NormalizerInterface};

final readonly class MoneyNormalizer implements NormalizerInterface, DenormalizerInterface
{
    public function normalize(mixed $object, ?string $format = null, array $context = []): array
    {
        return [
            'amount' => $object->getAmount(),
            'currency' => $object->getCurrency(),
        ];
    }

    public function supportsNormalization(mixed $data, ?string $format = null, array $context = []): bool
    {
        return $data instanceof Money;
    }

    public function denormalize(mixed $data, string $type, ?string $format = null, array $context = []): Money
    {
        return new Money($data['amount'], $data['currency']);
    }

    public function supportsDenormalization(mixed $data, string $type, ?string $format = null, array $context = []): bool
    {
        return $type === Money::class;
    }

    public function getSupportedTypes(?string $format): array
    {
        return [Money::class => true];
    }
}
```

**2. Auto-register normalizers:**

```yaml
services:
    App\Serializer\Normalizer\:
        resource: '../src/Serializer/Normalizer/'
        tags: ['serializer.normalizer']
```

**3. Control order with priority (optional):**

```yaml
services:
    App\Serializer\Normalizer\MoneyNormalizer:
        tags:
            - { name: 'serializer.normalizer', priority: 10 }
```

### Property Promotion Support

The custom `ObjectNormalizer` is configured with `propertyTypeExtractor` to support PHP 8 constructor property promotion:

```php
final readonly class OrderPlaced
{
    public function __construct(
        public Id $orderId,           // âœ… Property promotion works!
        public float $totalAmount,
        public CarbonImmutable $placedAt,
    ) {}
}
```

## Outbox Bridge Pattern

The `OutboxToAmqpBridge` is a **generic handler** that publishes all outbox events to AMQP:

```php
#[AsMessageHandler(fromTransport: 'outbox')]
public function __invoke(OutboxMessage $event): void
{
    $messageName = $this->extractMessageName($event);
    $messageId = Id::new();

    $exchange = $this->routingStrategy->getTransport($event, $messageName);
    $routingKey = $this->routingStrategy->getRoutingKey($event, $messageName);
    $headers = $this->routingStrategy->getHeaders($messageName);

    $envelope = new Envelope($event, [
        new MessageIdStamp($messageId->__toString()),
        new AmqpStamp($routingKey, AMQP_NOPARAM, $headers),
        new TransportNamesStamp(['amqp']),
    ]);

    $this->eventBus->dispatch($envelope);
}
```

**Benefits:**
- No code changes needed when adding new events
- All events automatically published to AMQP
- Convention-based routing with attribute overrides
- Failed publishing handled by Messenger's retry/failed transport
